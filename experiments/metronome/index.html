<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>AudioWorklet Metronome</title>
<style>
  body {
    font-family: Arial, sans-serif;
    text-align: center;
    margin: 2rem;
    background: #222;
    color: #eee;
  }
  label {
    display: inline-block;
    margin: 0 0.5rem 0.5rem 0;
    font-weight: bold;
  }
  input[type=number] {
    width: 60px;
    padding: 0.2rem 0.3rem;
    font-size: 1rem;
    border-radius: 4px;
    border: none;
    margin-right: 1rem;
  }
  button {
    font-size: 1.1rem;
    padding: 0.5rem 1rem;
    margin: 0.5rem;
    background: #444;
    border: none;
    color: #eee;
    border-radius: 4px;
    cursor: pointer;
    transition: background 0.3s;
  }
  button:hover {
    background: #666;
  }
  canvas {
    display: block;
    margin: 1rem auto;
    background: #111;
    border-radius: 50%;
    box-shadow: 0 0 15px #000 inset;
  }
  #counters {
    font-size: 1.2rem;
    margin-top: 0.5rem;
  }
  #counters span {
    margin: 0 1rem;
    user-select: none;
  }
</style>
</head>
<body>
  <h1>AudioWorklet Metronome</h1>

  <div>
    <label for="bpmInput">BPM:</label>
    <input id="bpmInput" type="number" min="20" max="300" value="120" step="1" />
    <label for="ppqnInput">PPQN:</label>
    <input id="ppqnInput" type="number" min="6" max="1920" value="24" step="1" />
  </div>

  <div>
    <button id="playPauseBtn">Play</button>
    <button id="stopBtn">Stop</button>
  </div>

  <canvas id="progressCanvas" width="250" height="250"></canvas>
  <div id="counters">
    <span id="tickCount">Tick: 0</span>
    <span id="beatCount">Beat: 0</span>
  </div>

  <!-- Clock worklet code inside template -->
  <template class="worklet-clock">
    <script>
      class ClockProcessor extends AudioWorkletProcessor {
        constructor() {
          super();
          this.bpm = 120;
          this.ppqn = 24;
          this.sampleRate = sampleRate;
          this.samplesPerTick = (60 / this.bpm / this.ppqn) * this.sampleRate;
          this.sampleCounter = 0;
          this.running = false;
          this.port.onmessage = (e) => {
            const data = e.data;
            if (data.type === 'start') {
              this.running = true;
            } else if (data.type === 'stop') {
              this.running = false;
              this.sampleCounter = 0;
            } else if (data.type === 'setBPM') {
              this.bpm = data.bpm;
              this.samplesPerTick = (60 / this.bpm / this.ppqn) * this.sampleRate;
            } else if (data.type === 'setPPQN') {
              this.ppqn = data.ppqn;
              this.samplesPerTick = (60 / this.bpm / this.ppqn) * this.sampleRate;
            }
          };
        }
        process(inputs, outputs, parameters) {
          if (!this.running) return true;
          const quantumSize = 128;
          this.sampleCounter += quantumSize;
          while (this.sampleCounter >= this.samplesPerTick) {
            this.sampleCounter -= this.samplesPerTick;
            this.port.postMessage('tick');
          }
          return true;
        }
      }
      registerProcessor('clock', ClockProcessor);
    </script>
  </template>

  <script>
    class Clock {
      constructor(ac, callback) {
        this.ac = ac;
        this.callback = callback;
      }
      async start() {
        await this.ac.resume();
        const template = document.querySelector('template.worklet-clock');
        const script = template.content.querySelector('script');
        const workletCode = script.textContent.trim();
        const dataURL = `data:text/javascript;base64,${btoa(workletCode)}`;
        await this.ac.audioWorklet.addModule(dataURL);
        this.node = new AudioWorkletNode(this.ac, "clock");
        this.node.connect(this.ac.destination);
        this.node.port.onmessage = (e) => this.callback(e.data);
        this.node.port.postMessage({ type: "start" });
      }
      stop() {
        this.node?.port.postMessage({ type: "stop" });
      }
    }

    // Initialize AudioContext outside async function
    const ctx = new AudioContext();

    // Create clock instance right away
    const clock = new Clock(ctx, (data) => {
      if (data === 'tick') {
        tickCount++;
        tickCountEl.textContent = `Tick: ${tickCount}`;
        if (tickCount % ppqn === 0) {
          beatCount++;
          beatCountEl.textContent = `Beat: ${beatCount}`;
          beatPulse = 1;  // Reset pulse for center boom
          playBeatBeep();
        }
      }
    });

    // Autoplay policy fix: resume AudioContext on first click
    document.addEventListener("click", function firstClick() {
      ctx.resume();
      document.removeEventListener("click", firstClick);
    });

    // Variables for tick/beat counters and UI elements
    let tickCount = 0;
    let beatCount = 0;
    let beatPulse = 0;
    let ppqn = 24;

    // UI elements refs (must be outside async for callback access)
    const bpmInput = document.getElementById('bpmInput');
    const ppqnInput = document.getElementById('ppqnInput');
    const playPauseBtn = document.getElementById('playPauseBtn');
    const stopBtn = document.getElementById('stopBtn');
    const tickCountEl = document.getElementById('tickCount');
    const beatCountEl = document.getElementById('beatCount');
    const canvas = document.getElementById('progressCanvas');
    const ctx2d = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    const centerX = width / 2;
    const centerY = height / 2;
    const maxLedRadius = 15;

    // This async function handles the rest of the setup (event handlers, drawing loop)
    (async () => {
      function playBeatBeep() {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'square';
        osc.frequency.value = 1320;
        gain.gain.setValueAtTime(0.3, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.07);
        osc.connect(gain).connect(ctx.destination);
        osc.start();
        osc.stop(ctx.currentTime + 0.07);
      }

      function draw() {
        ctx2d.clearRect(0, 0, width, height);

        const ringRadius = 100;

        ctx2d.beginPath();
        ctx2d.arc(centerX, centerY, ringRadius + maxLedRadius + 10, 0, 2 * Math.PI);
        ctx2d.fillStyle = '#111';
        ctx2d.fill();

        const currentTick = tickCount % ppqn;

        const spacingAngle = (2 * Math.PI) / ppqn;
        const maxLedDiameter = 2 * ringRadius * Math.sin(spacingAngle / 2) * 0.9;
        const ledRadiusDynamic = Math.min(maxLedRadius, maxLedDiameter / 2, 15);

        if (ppqn <= 128) {
          for (let i = 0; i < ppqn; i++) {
            const angle = (i / ppqn) * 2 * Math.PI - Math.PI / 2;
            const x = centerX + ringRadius * Math.cos(angle);
            const y = centerY + ringRadius * Math.sin(angle);

            ctx2d.beginPath();
            ctx2d.arc(x, y, ledRadiusDynamic, 0, 2 * Math.PI);

            if (i === currentTick) {
              ctx2d.fillStyle = 'rgba(0, 170, 255, 0.9)';
            } else {
              ctx2d.fillStyle = '#444';
              ctx2d.shadowBlur = 0;
            }
            ctx2d.fill();
          }
        } else {
          const thickness = 5;
          const startAngle = -Math.PI / 2;

          ctx2d.beginPath();
          ctx2d.arc(centerX, centerY, ringRadius, 0, 2 * Math.PI);
          ctx2d.lineWidth = thickness;
          ctx2d.strokeStyle = '#444';
          ctx2d.shadowBlur = 0;
          ctx2d.stroke();

          const progressAngle = (currentTick / ppqn) * 2 * Math.PI;
          ctx2d.beginPath();
          ctx2d.arc(centerX, centerY, ringRadius, startAngle, startAngle + progressAngle + 2);
          ctx2d.lineWidth = thickness;
          ctx2d.strokeStyle = 'rgba(0, 170, 255, 0.9)';
          ctx2d.shadowColor = 'rgba(0, 170, 255, 0.9)';
          ctx2d.stroke();
        }

        ctx2d.beginPath();
        ctx2d.arc(centerX, centerY, ringRadius - maxLedRadius - 10, 0, 2 * Math.PI);
        ctx2d.fillStyle = '#111';
        ctx2d.fill();

        if (beatPulse > 0) {
          const maxPulseRadius = ringRadius - maxLedRadius - 10;
          const pulseRadius = maxPulseRadius * (1 - beatPulse);
          const alpha = beatPulse * 0.5;

          ctx2d.beginPath();
          ctx2d.arc(centerX, centerY, pulseRadius, 0, 2 * Math.PI);
          ctx2d.strokeStyle = `rgba(255, 140, 0, ${alpha})`;
          ctx2d.lineWidth = 6 * beatPulse;
          ctx2d.shadowColor = `rgba(255, 140, 0, ${alpha})`;
          ctx2d.shadowBlur = 20 * alpha;
          ctx2d.stroke();

          beatPulse -= 0.03;
          if (beatPulse < 0) beatPulse = 0;
        }

        requestAnimationFrame(draw);
      }

      draw();

      playPauseBtn.addEventListener('click', async () => {
        if (!running) {
          if (ctx.state === 'suspended') {
            await ctx.resume();
          }
          await clock.start();
          running = true;
          playPauseBtn.textContent = 'Pause';
          tickCount = 0;
          beatCount = 0;
          tickCountEl.textContent = `Tick: ${tickCount}`;
          beatCountEl.textContent = `Beat: ${beatCount}`;
        } else {
          clock.stop();
          running = false;
          playPauseBtn.textContent = 'Play';
        }
      });

      stopBtn.addEventListener('click', () => {
        clock.stop();
        running = false;
        playPauseBtn.textContent = 'Play';
        tickCount = 0;
        beatCount = 0;
        tickCountEl.textContent = `Tick: ${tickCount}`;
        beatCountEl.textContent = `Beat: ${beatCount}`;
      });

      bpmInput.addEventListener('change', () => {
        const bpm = Math.min(300, Math.max(20, Number(bpmInput.value)));
        bpmInput.value = bpm;
        clock.node?.port.postMessage({ type: 'setBPM', bpm });
      });

      ppqnInput.addEventListener('change', () => {
        ppqn = Math.min(1920, Math.max(1, Number(ppqnInput.value)));
        ppqnInput.value = ppqn;
        clock.node?.port.postMessage({ type: 'setPPQN', ppqn });
      });

      let running = false;
    })();
  </script>
</body>
</html>
